description: Common checks for all roles
parameters:
  hostname:           hostname -f 2>/dev/null || hostname
  time_utc:           LANG=C date --utc
  time:               LANG=C date
  umask:              umask
  ntp_service_status: service ntpd status 2>&1
  OS:                 lsb_release --short --id --release | xargs
  architecture:       uname --machine
  ram:       awk '$1=="MemTotal:" {printf("%.3f GB",$2/1024/1024)}' /proc/meminfo
  swap:      awk '$1=="SwapTotal:"{printf("%.3f GB",$2/1024/1024)}' /proc/meminfo
  selinux:   which getenforce >/dev/null && getenforce || echo no selinux
  yum_repos: which yum >/dev/null
             && echo $(yum repolist | sed '/repo id/,$ !d' 
                    | sed -e '1 d' -e '$ d' | awk '{ print $1}' | xargs)
             || echo no yum
  processors:
    _type: dictionary
    count:     grep --fixed-strings processor -c /proc/cpuinfo
    model:     grep --fixed-strings --max-count=1 'model name' /proc/cpuinfo | awk -F':' '{print $2}' | sed 's/^ //g'
    frequency: grep --fixed-strings --max-count=1 'cpu MHz' /proc/cpuinfo 
               | awk '{printf("%.1fGHz",$NF/1000)}'
  disks:
    _type: table
    _fields: [mountpoint, size, fs_type, device]
    _separator: ' '
    _command: df --human-readable --print-type --exclude tmpfs --exclude devtmpfs
                --portability | tac | head --lines=-1 | awk '{print $NF,$3,$2,$1}'
  network:
    _type: dictionary 
    name_servers: awk '$1=="nameserver"{print $2}' /etc/resolv.conf | xargs
    dns_check: host -t soa google.com | grep -q 'has SOA record' && echo OK || echo NOT OK
    network_interfaces:
      _type: list
      # generator will be evaluated first, each line adds element to list
      # then, for each new element, other fields will be evalueted with generator as dependency
      # form:
      # _generator: {field_name: placeholder_name}
      _generator: {name: name}
      name:   /sbin/ip --oneline link show | grep --fixed-strings --invert-match 'link/loopback'
              | awk '{print $2}' | sed 's/:$//'
      state:  /sbin/ip --oneline link show dev %(name)s 
              | grep --only-matching --extended-regexp ' state (UP|DOWN|UNKNOWN) ' 
              | awk '{print $2}'
      hwaddr: /sbin/ip --oneline link show dev %(name)s
              | grep --only-matching --extended-regexp ' link/.*'
              | awk '{print $2}'
      gateway: /sbin/ip route list dev %(name)s | grep ^default | awk '{print $3}'
      ip:
        _type: table
        _fields: [address, prefix, network]
        _separator: ' '
        # _uses: {key1: placeholder1, key2: placeholder2}
        # for each key data from config['key'] will be stored in temporary file
        # and file name will be substitution for corresponding placeholder in script or command
        _uses: {networks: networks_file}
        _script: |
          #!/bin/bash
          { /sbin/ip -family inet -oneline address list scope global dev %(name)s;
            /sbin/ip -family inet6 -oneline address list scope global dev %(name)s; } \
          | awk '{print $4}' | tr '/' ' ' \
          | while read ip prefix; do
              netaddr=$( { /sbin/ip -family inet route list dev %(name)s;
                           /sbin/ip -family inet6 route list dev %(name)s; } \
                         | grep " src $ip" | awk '{print $1}' | sed 's|/[0-9]*$||' )
              if [ -z "$netaddr" ]; then
                netname="no_route_with_this_ip_as_src"
              else
                netname=$(grep --fixed-strings "address: $netaddr" "%(networks_file)s" \
                          | grep --fixed-strings "prefix: $prefix" \
                          | grep --only-matching --extended-regexp "name: [^ ,}]+" \
                          | awk '{print $2}')
              fi
              [ -z "$netname" ] && netname=$netaddr
              echo $ip $prefix $netname
          done
          exit 0
# firewal - set of rules
firewall:
    - name: SSH Access
      description: Allow SSH access over backnet from linmn
      # policy: allow/deny
      policy: allow
      # direction: incoming/outgoing
      direction: incoming
      networks: [backnet]
      # proto: TCP/UDP/ICMP
      protos: [TCP]
      ports: [22]
      # type: infra/internet
      type: infra
      connect_with:
        # roles are for type = infra
        roles: [linmn]
        # hosts are for type = internet, host can be IP/FQDN, like 8.8.8.8 or ya.ru
        hosts: []
        # smtprelay, dnsresolver, hwswa_host: yes/no, no by default
        #smtprelay: no
        #dnsresolver: no
        #hwswa_host: no
